{"version":3,"sources":["index.js","container/OtherContainer/Stack.js","container/ContainerBase/index.js","container/OtherContainer/Queue.js","container/SequentialContainer/Deque.js","container/SequentialContainer/Base/index.js","utils/checkParams.js","container/SequentialContainer/Base/RandomIterator.js","container/OtherContainer/PriorityQueue.js","container/SequentialContainer/Vector.js","container/SequentialContainer/LinkList.js","container/TreeContainer/OrderedSet.js","container/TreeContainer/Base/index.js","container/TreeContainer/Base/TreeNode.js","container/TreeContainer/Base/TreeIterator.js","container/TreeContainer/OrderedMap.js","container/HashContainer/HashSet.js","container/HashContainer/Base/index.js","container/HashContainer/HashMap.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AIZA,ADGA,AJYA;AELA,ACHA,AFMA,AIZA,ADGA,AJYA;AELA,ACHA,AFMA,AIZA,ADGA,AJYA;AELA,ACHA,AFMA,AIZA,ADGA,AJYA,AMlBA;AJaA,ACHA,AFMA,AIZA,ADGA,AJYA,AMlBA;AJaA,ACHA,AFMA,AIZA,ADGA,AJYA,AMlBA;AJaA,ACHA,AFMA,AMlBA,AFMA,ADGA,AJYA,AMlBA;AJaA,ACHA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AJaA,ACHA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AJYA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AKfA,AT2BA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AKfA,AT2BA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AKfA,AT2BA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AT2BA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AT2BA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AT2BA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AENA,AXiCA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AENA,AXiCA,AMlBA;AJaA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AENA,AXiCA;AELA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AGTA,ADGA,AXiCA;AELA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AGTA,ADGA,AXiCA;AELA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AGTA,ADGA,AXiCA;AELA,AMlBA,ALeA,AFMA,AMlBA,AHSA,AMlBA,ADGA,AIZA,ADGA,ADGA,AXiCA;AELA,AMlBA,ALeA,AIZA,AHSA,AMlBA,ADGA,AIZA,ADGA,ADGA,AXiCA;AELA,AMlBA,ALeA,AIZA,AHSA,AMlBA,ADGA,AIZA,ADGA,ADGA;AT4BA,AMlBA,ALeA,AIZA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,ADGA;AHUA,ALeA,AIZA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,ADGA;AHUA,ALeA,AIZA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,ADGA;AHUA,ALeA,AIZA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AHUA,ALeA,AIZA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AHUA,ALeA,AIZA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AKdA,ARwBA,ALeA,AIZA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AKdA,ARwBA,ALeA,AIZA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AKdA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ADGA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ADGA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ADGA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,ADGA,AHSA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AKfA,ADGA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AMjBA,ACHA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA,AJYA;AOpBA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,ARwBA,AJYA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AIZA,ADGA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AGTA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AGTA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AGTA,AGTA;AGRA,AFMA,AZoCA,AMlBA,ADGA,AGTA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA,AGTA;AGRA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,AFMA,AZoCA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;AMjBA,Ad0CA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;ARyBA,AMlBA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HashContainer = exports.TreeContainer = exports.SequentialContainer = exports.ContainerIterator = exports.Container = exports.HashMap = exports.HashSet = exports.OrderedMapIterator = exports.OrderedMap = exports.OrderedSetIterator = exports.OrderedSet = exports.DequeIterator = exports.Deque = exports.LinkListIterator = exports.LinkList = exports.VectorIterator = exports.Vector = exports.PriorityQueue = exports.Queue = exports.Stack = void 0;\nvar Stack_1 = require(\"./container/OtherContainer/Stack\");\nObject.defineProperty(exports, \"Stack\", { enumerable: true, get: function () { return __importDefault(Stack_1).default; } });\nvar Queue_1 = require(\"./container/OtherContainer/Queue\");\nObject.defineProperty(exports, \"Queue\", { enumerable: true, get: function () { return __importDefault(Queue_1).default; } });\nvar PriorityQueue_1 = require(\"./container/OtherContainer/PriorityQueue\");\nObject.defineProperty(exports, \"PriorityQueue\", { enumerable: true, get: function () { return __importDefault(PriorityQueue_1).default; } });\nvar Vector_1 = require(\"./container/SequentialContainer/Vector\");\nObject.defineProperty(exports, \"Vector\", { enumerable: true, get: function () { return __importDefault(Vector_1).default; } });\nObject.defineProperty(exports, \"VectorIterator\", { enumerable: true, get: function () { return Vector_1.VectorIterator; } });\nvar LinkList_1 = require(\"./container/SequentialContainer/LinkList\");\nObject.defineProperty(exports, \"LinkList\", { enumerable: true, get: function () { return __importDefault(LinkList_1).default; } });\nObject.defineProperty(exports, \"LinkListIterator\", { enumerable: true, get: function () { return LinkList_1.LinkListIterator; } });\nvar Deque_1 = require(\"./container/SequentialContainer/Deque\");\nObject.defineProperty(exports, \"Deque\", { enumerable: true, get: function () { return __importDefault(Deque_1).default; } });\nObject.defineProperty(exports, \"DequeIterator\", { enumerable: true, get: function () { return Deque_1.DequeIterator; } });\nvar OrderedSet_1 = require(\"./container/TreeContainer/OrderedSet\");\nObject.defineProperty(exports, \"OrderedSet\", { enumerable: true, get: function () { return __importDefault(OrderedSet_1).default; } });\nObject.defineProperty(exports, \"OrderedSetIterator\", { enumerable: true, get: function () { return OrderedSet_1.OrderedSetIterator; } });\nvar OrderedMap_1 = require(\"./container/TreeContainer/OrderedMap\");\nObject.defineProperty(exports, \"OrderedMap\", { enumerable: true, get: function () { return __importDefault(OrderedMap_1).default; } });\nObject.defineProperty(exports, \"OrderedMapIterator\", { enumerable: true, get: function () { return OrderedMap_1.OrderedMapIterator; } });\nvar HashSet_1 = require(\"./container/HashContainer/HashSet\");\nObject.defineProperty(exports, \"HashSet\", { enumerable: true, get: function () { return __importDefault(HashSet_1).default; } });\nvar HashMap_1 = require(\"./container/HashContainer/HashMap\");\nObject.defineProperty(exports, \"HashMap\", { enumerable: true, get: function () { return __importDefault(HashMap_1).default; } });\nvar index_1 = require(\"./container/ContainerBase/index\");\nObject.defineProperty(exports, \"Container\", { enumerable: true, get: function () { return index_1.Container; } });\nObject.defineProperty(exports, \"ContainerIterator\", { enumerable: true, get: function () { return index_1.ContainerIterator; } });\nvar index_2 = require(\"./container/SequentialContainer/Base/index\");\nObject.defineProperty(exports, \"SequentialContainer\", { enumerable: true, get: function () { return __importDefault(index_2).default; } });\nvar index_3 = require(\"./container/TreeContainer/Base/index\");\nObject.defineProperty(exports, \"TreeContainer\", { enumerable: true, get: function () { return __importDefault(index_3).default; } });\nvar index_4 = require(\"./container/HashContainer/Base/index\");\nObject.defineProperty(exports, \"HashContainer\", { enumerable: true, get: function () { return __importDefault(index_4).default; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = require(\"../ContainerBase/index\");\nclass Stack extends index_1.Base {\n    constructor(container = []) {\n        super();\n        this.stack = [];\n        container.forEach(element => this.push(element));\n    }\n    clear() {\n        this.length = 0;\n        this.stack.length = 0;\n    }\n    /**\n     * @description Insert element to stack's end.\n     */\n    push(element) {\n        this.stack.push(element);\n        this.length += 1;\n    }\n    /**\n     * @description Removes the end element.\n     */\n    pop() {\n        this.stack.pop();\n        if (this.length > 0)\n            this.length -= 1;\n    }\n    /**\n     * @description Accesses the end element.\n     */\n    top() {\n        return this.stack[this.length - 1];\n    }\n}\nexports.default = Stack;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Container = exports.Base = exports.ContainerIterator = void 0;\nclass ContainerIterator {\n    constructor(iteratorType = ContainerIterator.NORMAL) {\n        this.iteratorType = iteratorType;\n    }\n}\nexports.ContainerIterator = ContainerIterator;\nContainerIterator.NORMAL = false;\nContainerIterator.REVERSE = true;\nclass Base {\n    constructor() {\n        /**\n         * @description Container's size.\n         * @protected\n         */\n        this.length = 0;\n    }\n    /**\n     * @return The size of the container.\n     */\n    size() {\n        return this.length;\n    }\n    /**\n     * @return Boolean about if the container is empty.\n     */\n    empty() {\n        return this.length === 0;\n    }\n}\nexports.Base = Base;\nclass Container extends Base {\n}\nexports.Container = Container;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Deque_1 = __importDefault(require(\"../SequentialContainer/Deque\"));\nconst index_1 = require(\"../ContainerBase/index\");\nclass Queue extends index_1.Base {\n    constructor(container = []) {\n        super();\n        this.queue = new Deque_1.default(container);\n        this.length = this.queue.size();\n    }\n    clear() {\n        this.queue.clear();\n        this.length = 0;\n    }\n    /**\n     * @description Inserts element to queue's end.\n     */\n    push(element) {\n        this.queue.pushBack(element);\n        this.length += 1;\n    }\n    /**\n     * @description Removes the first element.\n     */\n    pop() {\n        this.queue.popFront();\n        if (this.length)\n            this.length -= 1;\n    }\n    /**\n     * @description Access the first element.\n     */\n    front() {\n        return this.queue.front();\n    }\n}\nexports.default = Queue;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DequeIterator = void 0;\nconst index_1 = __importDefault(require(\"./Base/index\"));\nconst checkParams_1 = require(\"../../utils/checkParams\");\nconst index_2 = require(\"../ContainerBase/index\");\nconst RandomIterator_1 = require(\"./Base/RandomIterator\");\nclass DequeIterator extends RandomIterator_1.RandomIterator {\n    copy() {\n        return new DequeIterator(this.node, this.size, this.getElementByPos, this.setElementByPos, this.iteratorType);\n    }\n}\nexports.DequeIterator = DequeIterator;\nclass Deque extends index_1.default {\n    constructor(container = [], bucketSize = (1 << 12)) {\n        super();\n        this.first = 0;\n        this.curFirst = 0;\n        this.last = 0;\n        this.curLast = 0;\n        this.bucketNum = 0;\n        this.map = [];\n        let _length;\n        if ('size' in container) {\n            if (typeof container.size === 'number') {\n                _length = container.size;\n            }\n            else {\n                _length = container.size();\n            }\n        }\n        else if ('length' in container) {\n            _length = container.length;\n        }\n        else {\n            throw new RangeError('Can\\'t get container\\'s size!');\n        }\n        this.bucketSize = bucketSize;\n        this.bucketNum = Math.max(Math.ceil(_length / this.bucketSize), 1);\n        for (let i = 0; i < this.bucketNum; ++i) {\n            this.map.push(new Array(this.bucketSize));\n        }\n        const needBucketNum = Math.ceil(_length / this.bucketSize);\n        this.first = this.last = (this.bucketNum >> 1) - (needBucketNum >> 1);\n        this.curFirst = this.curLast = (this.bucketSize - _length % this.bucketSize) >> 1;\n        container.forEach(element => this.pushBack(element));\n        this.size = this.size.bind(this);\n        this.getElementByPos = this.getElementByPos.bind(this);\n        this.setElementByPos = this.setElementByPos.bind(this);\n    }\n    /**\n     * @description Growth the Deque.\n     * @private\n     */\n    reAllocate() {\n        const newMap = [];\n        const addBucketNum = Math.max(this.bucketNum >> 1, 1);\n        for (let i = 0; i < addBucketNum; ++i) {\n            newMap[i] = new Array(this.bucketSize);\n        }\n        for (let i = this.first; i < this.bucketNum; ++i) {\n            newMap[newMap.length] = this.map[i];\n        }\n        for (let i = 0; i < this.last; ++i) {\n            newMap[newMap.length] = this.map[i];\n        }\n        newMap[newMap.length] = [...this.map[this.last]];\n        this.first = addBucketNum;\n        this.last = newMap.length - 1;\n        for (let i = 0; i < addBucketNum; ++i) {\n            newMap[newMap.length] = new Array(this.bucketSize);\n        }\n        this.map = newMap;\n        this.bucketNum = newMap.length;\n    }\n    /**\n     * @description Get the bucket position of the element and the pointer position by index.\n     * @param pos The element's index.\n     * @private\n     */\n    getElementIndex(pos) {\n        const offset = this.curFirst + pos + 1;\n        const offsetRemainder = offset % this.bucketSize;\n        let curNodePointerIndex = offsetRemainder - 1;\n        let curNodeBucketIndex = this.first + (offset - offsetRemainder) / this.bucketSize;\n        if (offsetRemainder === 0)\n            curNodeBucketIndex -= 1;\n        curNodeBucketIndex %= this.bucketNum;\n        if (curNodePointerIndex < 0)\n            curNodePointerIndex += this.bucketSize;\n        return { curNodeBucketIndex, curNodePointerIndex };\n    }\n    clear() {\n        this.map = [[]];\n        this.bucketNum = 1;\n        this.first = this.last = this.length = 0;\n        this.curFirst = this.curLast = this.bucketSize >> 1;\n    }\n    front() {\n        return this.map[this.first][this.curFirst];\n    }\n    back() {\n        return this.map[this.last][this.curLast];\n    }\n    begin() {\n        return new DequeIterator(0, this.size, this.getElementByPos, this.setElementByPos);\n    }\n    end() {\n        return new DequeIterator(this.length, this.size, this.getElementByPos, this.setElementByPos);\n    }\n    rBegin() {\n        return new DequeIterator(this.length - 1, this.size, this.getElementByPos, this.setElementByPos, index_2.ContainerIterator.REVERSE);\n    }\n    rEnd() {\n        return new DequeIterator(-1, this.size, this.getElementByPos, this.setElementByPos, index_2.ContainerIterator.REVERSE);\n    }\n    pushBack(element) {\n        if (this.length) {\n            if (this.curLast < this.bucketSize - 1) {\n                this.curLast += 1;\n            }\n            else if (this.last < this.bucketNum - 1) {\n                this.last += 1;\n                this.curLast = 0;\n            }\n            else {\n                this.last = 0;\n                this.curLast = 0;\n            }\n            if (this.last === this.first &&\n                this.curLast === this.curFirst)\n                this.reAllocate();\n        }\n        this.length += 1;\n        this.map[this.last][this.curLast] = element;\n    }\n    popBack() {\n        if (!this.length)\n            return;\n        this.map[this.last][this.curLast] = undefined;\n        if (this.length !== 1) {\n            if (this.curLast > 0) {\n                this.curLast -= 1;\n            }\n            else if (this.last > 0) {\n                this.last -= 1;\n                this.curLast = this.bucketSize - 1;\n            }\n            else {\n                this.last = this.bucketNum - 1;\n                this.curLast = this.bucketSize - 1;\n            }\n        }\n        this.length -= 1;\n    }\n    /**\n     * @description Push the element to the front.\n     * @param element The element you want to push.\n     */\n    pushFront(element) {\n        if (this.length) {\n            if (this.curFirst > 0) {\n                this.curFirst -= 1;\n            }\n            else if (this.first > 0) {\n                this.first -= 1;\n                this.curFirst = this.bucketSize - 1;\n            }\n            else {\n                this.first = this.bucketNum - 1;\n                this.curFirst = this.bucketSize - 1;\n            }\n            if (this.first === this.last &&\n                this.curFirst === this.curLast)\n                this.reAllocate();\n        }\n        this.length += 1;\n        this.map[this.first][this.curFirst] = element;\n    }\n    /**\n     * @description Remove the first element.\n     */\n    popFront() {\n        if (!this.length)\n            return;\n        this.map[this.first][this.curFirst] = undefined;\n        if (this.length !== 1) {\n            if (this.curFirst < this.bucketSize - 1) {\n                this.curFirst += 1;\n            }\n            else if (this.first < this.bucketNum - 1) {\n                this.first += 1;\n                this.curFirst = 0;\n            }\n            else {\n                this.first = 0;\n                this.curFirst = 0;\n            }\n        }\n        this.length -= 1;\n    }\n    forEach(callback) {\n        for (let i = 0; i < this.length; ++i) {\n            callback(this.getElementByPos(i), i);\n        }\n    }\n    getElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        const { curNodeBucketIndex, curNodePointerIndex } = this.getElementIndex(pos);\n        return this.map[curNodeBucketIndex][curNodePointerIndex];\n    }\n    setElementByPos(pos, element) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        const { curNodeBucketIndex, curNodePointerIndex } = this.getElementIndex(pos);\n        this.map[curNodeBucketIndex][curNodePointerIndex] = element;\n    }\n    insert(pos, element, num = 1) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length);\n        if (pos === 0) {\n            while (num--)\n                this.pushFront(element);\n        }\n        else if (pos === this.length) {\n            while (num--)\n                this.pushBack(element);\n        }\n        else {\n            const arr = [];\n            for (let i = pos; i < this.length; ++i) {\n                arr.push(this.getElementByPos(i));\n            }\n            this.cut(pos - 1);\n            for (let i = 0; i < num; ++i)\n                this.pushBack(element);\n            for (let i = 0; i < arr.length; ++i)\n                this.pushBack(arr[i]);\n        }\n    }\n    /**\n     * @description Remove all elements after the specified position (excluding the specified position).\n     * @param pos The previous position of the first removed element.\n     * @example deque.cut(1); // Then deque's size will be 2. deque -> [0, 1]\n     */\n    cut(pos) {\n        if (pos < 0) {\n            this.clear();\n            return;\n        }\n        const { curNodeBucketIndex, curNodePointerIndex } = this.getElementIndex(pos);\n        this.last = curNodeBucketIndex;\n        this.curLast = curNodePointerIndex;\n        this.length = pos + 1;\n    }\n    eraseElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        if (pos === 0)\n            this.popFront();\n        else if (pos === this.length - 1)\n            this.popBack();\n        else {\n            const arr = [];\n            for (let i = pos + 1; i < this.length; ++i) {\n                arr.push(this.getElementByPos(i));\n            }\n            this.cut(pos);\n            this.popBack();\n            arr.forEach(element => this.pushBack(element));\n        }\n    }\n    eraseElementByValue(value) {\n        if (!this.length)\n            return;\n        const arr = [];\n        for (let i = 0; i < this.length; ++i) {\n            const element = this.getElementByPos(i);\n            if (element !== value)\n                arr.push(element);\n        }\n        const _length = arr.length;\n        for (let i = 0; i < _length; ++i)\n            this.setElementByPos(i, arr[i]);\n        this.cut(_length - 1);\n    }\n    eraseElementByIterator(iter) {\n        // @ts-ignore\n        const node = iter.node;\n        this.eraseElementByPos(node);\n        iter = iter.next();\n        return iter;\n    }\n    find(element) {\n        for (let i = 0; i < this.length; ++i) {\n            if (this.getElementByPos(i) === element) {\n                return new DequeIterator(i, this.size, this.getElementByPos, this.setElementByPos);\n            }\n        }\n        return this.end();\n    }\n    reverse() {\n        let l = 0;\n        let r = this.length - 1;\n        while (l < r) {\n            const tmp = this.getElementByPos(l);\n            this.setElementByPos(l, this.getElementByPos(r));\n            this.setElementByPos(r, tmp);\n            l += 1;\n            r -= 1;\n        }\n    }\n    unique() {\n        if (this.length <= 1)\n            return;\n        let index = 1;\n        let pre = this.getElementByPos(0);\n        for (let i = 1; i < this.length; ++i) {\n            const cur = this.getElementByPos(i);\n            if (cur !== pre) {\n                pre = cur;\n                this.setElementByPos(index++, cur);\n            }\n        }\n        while (this.length > index)\n            this.popBack();\n    }\n    sort(cmp) {\n        const arr = [];\n        for (let i = 0; i < this.length; ++i) {\n            arr.push(this.getElementByPos(i));\n        }\n        arr.sort(cmp);\n        for (let i = 0; i < this.length; ++i)\n            this.setElementByPos(i, arr[i]);\n    }\n    /**\n     * @description Remove as much useless space as possible.\n     */\n    shrinkToFit() {\n        if (!this.length)\n            return;\n        const arr = [];\n        this.forEach(element => arr.push(element));\n        this.bucketNum = Math.max(Math.ceil(this.length / this.bucketSize), 1);\n        this.length = this.first = this.last = this.curFirst = this.curLast = 0;\n        this.map = [];\n        for (let i = 0; i < this.bucketNum; ++i) {\n            this.map.push(new Array(this.bucketSize));\n        }\n        for (let i = 0; i < arr.length; ++i)\n            this.pushBack(arr[i]);\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            for (let i = 0; i < this.length; ++i) {\n                yield this.getElementByPos(i);\n            }\n        }.bind(this)();\n    }\n}\nexports.default = Deque;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = require(\"../../ContainerBase/index\");\nclass SequentialContainer extends index_1.Container {\n}\nexports.default = SequentialContainer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkWithinAccessParams = void 0;\n/**\n * @description Check if access is out of bounds.\n * @param pos The position want to access.\n * @param lower The lower bound.\n * @param upper The upper bound.\n * @return Boolean about if access is out of bounds.\n */\nfunction checkWithinAccessParams(pos, lower, upper) {\n    if (pos < lower || pos > upper) {\n        throw new RangeError();\n    }\n}\nexports.checkWithinAccessParams = checkWithinAccessParams;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RandomIterator = void 0;\nconst checkParams_1 = require(\"../../../utils/checkParams\");\nconst index_1 = require(\"../../ContainerBase/index\");\nclass RandomIterator extends index_1.ContainerIterator {\n    constructor(index, size, getElementByPos, setElementByPos, iteratorType) {\n        super(iteratorType);\n        this.node = index;\n        this.size = size;\n        this.getElementByPos = getElementByPos;\n        this.setElementByPos = setElementByPos;\n        if (this.iteratorType === index_1.ContainerIterator.NORMAL) {\n            this.pre = function () {\n                if (this.node === 0) {\n                    throw new RangeError('Deque iterator access denied!');\n                }\n                this.node -= 1;\n                return this;\n            };\n            this.next = function () {\n                if (this.node === this.size()) {\n                    throw new RangeError('Deque Iterator access denied!');\n                }\n                this.node += 1;\n                return this;\n            };\n        }\n        else {\n            this.pre = function () {\n                if (this.node === this.size() - 1) {\n                    throw new RangeError('Deque iterator access denied!');\n                }\n                this.node += 1;\n                return this;\n            };\n            this.next = function () {\n                if (this.node === -1) {\n                    throw new RangeError('Deque iterator access denied!');\n                }\n                this.node -= 1;\n                return this;\n            };\n        }\n    }\n    get pointer() {\n        (0, checkParams_1.checkWithinAccessParams)(this.node, 0, this.size() - 1);\n        return this.getElementByPos(this.node);\n    }\n    set pointer(newValue) {\n        (0, checkParams_1.checkWithinAccessParams)(this.node, 0, this.size() - 1);\n        this.setElementByPos(this.node, newValue);\n    }\n    equals(obj) {\n        return this.node === obj.node;\n    }\n}\nexports.RandomIterator = RandomIterator;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = require(\"../ContainerBase/index\");\nclass PriorityQueue extends index_1.Base {\n    /**\n     * @description PriorityQueue's constructor.\n     * @param container Initialize container, must have a forEach function.\n     * @param cmp Compare function.\n     * @param copy When the container is an array, you can choose to directly operate on the original object of\n     *             the array or perform a shallow copy. The default is shallow copy.\n     */\n    constructor(container = [], cmp = (x, y) => {\n        if (x > y)\n            return -1;\n        if (x < y)\n            return 1;\n        return 0;\n    }, copy = true) {\n        super();\n        this.cmp = cmp;\n        if (Array.isArray(container)) {\n            this.priorityQueue = copy ? [...container] : container;\n        }\n        else {\n            this.priorityQueue = [];\n            container.forEach(element => this.priorityQueue.push(element));\n        }\n        this.length = this.priorityQueue.length;\n        for (let parent = (this.length - 1) >> 1; parent >= 0; --parent) {\n            let curParent = parent;\n            let curChild = (curParent << 1) | 1;\n            while (curChild < this.length) {\n                const left = curChild;\n                const right = left + 1;\n                let minChild = left;\n                if (right < this.length &&\n                    this.cmp(this.priorityQueue[left], this.priorityQueue[right]) > 0) {\n                    minChild = right;\n                }\n                if (this.cmp(this.priorityQueue[curParent], this.priorityQueue[minChild]) <= 0)\n                    break;\n                [this.priorityQueue[curParent], this.priorityQueue[minChild]] =\n                    [this.priorityQueue[minChild], this.priorityQueue[curParent]];\n                curParent = minChild;\n                curChild = (curParent << 1) | 1;\n            }\n        }\n    }\n    /**\n     * @description Adjusting parent's children to suit the nature of the heap.\n     * @param parent Parent's index.\n     * @private\n     */\n    adjust(parent) {\n        const left = (parent << 1) | 1;\n        const right = (parent << 1) + 2;\n        if (left < this.length &&\n            this.cmp(this.priorityQueue[parent], this.priorityQueue[left]) > 0) {\n            [this.priorityQueue[parent], this.priorityQueue[left]] =\n                [this.priorityQueue[left], this.priorityQueue[parent]];\n        }\n        if (right < this.length &&\n            this.cmp(this.priorityQueue[parent], this.priorityQueue[right]) > 0) {\n            [this.priorityQueue[parent], this.priorityQueue[right]] =\n                [this.priorityQueue[right], this.priorityQueue[parent]];\n        }\n    }\n    clear() {\n        this.length = 0;\n        this.priorityQueue.length = 0;\n    }\n    /**\n     * @description Push element into a container in order.\n     * @param element The element you want to push.\n     */\n    push(element) {\n        this.priorityQueue.push(element);\n        this.length += 1;\n        if (this.length === 1)\n            return;\n        let curNode = this.length - 1;\n        while (curNode > 0) {\n            const parent = (curNode - 1) >> 1;\n            if (this.cmp(this.priorityQueue[parent], element) <= 0)\n                break;\n            this.adjust(parent);\n            curNode = parent;\n        }\n    }\n    /**\n     * @description Removes the top element.\n     */\n    pop() {\n        if (!this.length)\n            return;\n        const last = this.priorityQueue[this.length - 1];\n        this.length -= 1;\n        let parent = 0;\n        while (parent < this.length) {\n            const left = (parent << 1) | 1;\n            const right = (parent << 1) + 2;\n            if (left >= this.length)\n                break;\n            let minChild = left;\n            if (right < this.length &&\n                this.cmp(this.priorityQueue[left], this.priorityQueue[right]) > 0) {\n                minChild = right;\n            }\n            if (this.cmp(this.priorityQueue[minChild], last) >= 0)\n                break;\n            this.priorityQueue[parent] = this.priorityQueue[minChild];\n            parent = minChild;\n        }\n        this.priorityQueue[parent] = last;\n        this.priorityQueue.pop();\n    }\n    /**\n     * @description Accesses the top element.\n     */\n    top() {\n        return this.priorityQueue[0];\n    }\n}\nexports.default = PriorityQueue;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorIterator = void 0;\nconst index_1 = __importDefault(require(\"./Base/index\"));\nconst checkParams_1 = require(\"../../utils/checkParams\");\nconst index_2 = require(\"../ContainerBase/index\");\nconst RandomIterator_1 = require(\"./Base/RandomIterator\");\nclass VectorIterator extends RandomIterator_1.RandomIterator {\n    copy() {\n        return new VectorIterator(this.node, this.size, this.getElementByPos, this.setElementByPos, this.iteratorType);\n    }\n}\nexports.VectorIterator = VectorIterator;\nclass Vector extends index_1.default {\n    /**\n     * @description Vector's constructor.\n     * @param container Initialize container, must have a forEach function.\n     * @param copy When the container is an array, you can choose to directly operate on the original object of\n     *             the array or perform a shallow copy. The default is shallow copy.\n     */\n    constructor(container = [], copy = true) {\n        super();\n        if (Array.isArray(container)) {\n            this.vector = copy ? [...container] : container;\n            this.length = container.length;\n        }\n        else {\n            this.vector = [];\n            container.forEach(element => this.pushBack(element));\n        }\n        this.size = this.size.bind(this);\n        this.getElementByPos = this.getElementByPos.bind(this);\n        this.setElementByPos = this.setElementByPos.bind(this);\n    }\n    clear() {\n        this.length = 0;\n        this.vector.length = 0;\n    }\n    begin() {\n        return new VectorIterator(0, this.size, this.getElementByPos, this.setElementByPos);\n    }\n    end() {\n        return new VectorIterator(this.length, this.size, this.getElementByPos, this.setElementByPos);\n    }\n    rBegin() {\n        return new VectorIterator(this.length - 1, this.size, this.getElementByPos, this.setElementByPos, index_2.ContainerIterator.REVERSE);\n    }\n    rEnd() {\n        return new VectorIterator(-1, this.size, this.getElementByPos, this.setElementByPos, index_2.ContainerIterator.REVERSE);\n    }\n    front() {\n        return this.vector[0];\n    }\n    back() {\n        return this.vector[this.length - 1];\n    }\n    forEach(callback) {\n        for (let i = 0; i < this.length; ++i) {\n            callback(this.vector[i], i);\n        }\n    }\n    getElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        return this.vector[pos];\n    }\n    eraseElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        this.vector.splice(pos, 1);\n        this.length -= 1;\n    }\n    eraseElementByValue(value) {\n        let index = 0;\n        for (let i = 0; i < this.length; ++i) {\n            if (this.vector[i] !== value) {\n                this.vector[index++] = this.vector[i];\n            }\n        }\n        this.length = this.vector.length = index;\n    }\n    eraseElementByIterator(iter) {\n        // @ts-ignore\n        const node = iter.node;\n        iter = iter.next();\n        this.eraseElementByPos(node);\n        return iter;\n    }\n    pushBack(element) {\n        this.vector.push(element);\n        this.length += 1;\n    }\n    popBack() {\n        if (!this.length)\n            return;\n        this.vector.pop();\n        this.length -= 1;\n    }\n    setElementByPos(pos, element) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        this.vector[pos] = element;\n    }\n    insert(pos, element, num = 1) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length);\n        this.vector.splice(pos, 0, ...new Array(num).fill(element));\n        this.length += num;\n    }\n    find(element) {\n        for (let i = 0; i < this.length; ++i) {\n            if (this.vector[i] === element) {\n                return new VectorIterator(i, this.size, this.getElementByPos, this.getElementByPos);\n            }\n        }\n        return this.end();\n    }\n    reverse() {\n        this.vector.reverse();\n    }\n    unique() {\n        let index = 1;\n        for (let i = 1; i < this.length; ++i) {\n            if (this.vector[i] !== this.vector[i - 1]) {\n                this.vector[index++] = this.vector[i];\n            }\n        }\n        this.length = this.vector.length = index;\n    }\n    sort(cmp) {\n        this.vector.sort(cmp);\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            return yield* this.vector;\n        }.bind(this)();\n    }\n}\nexports.default = Vector;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkListIterator = exports.LinkNode = void 0;\nconst index_1 = __importDefault(require(\"./Base/index\"));\nconst checkParams_1 = require(\"../../utils/checkParams\");\nconst index_2 = require(\"../ContainerBase/index\");\nclass LinkNode {\n    constructor(element) {\n        this.value = undefined;\n        this.pre = undefined;\n        this.next = undefined;\n        this.value = element;\n    }\n}\nexports.LinkNode = LinkNode;\nclass LinkListIterator extends index_2.ContainerIterator {\n    constructor(node, header, iteratorType) {\n        super(iteratorType);\n        this.node = node;\n        this.header = header;\n        if (this.iteratorType === index_2.ContainerIterator.NORMAL) {\n            this.pre = function () {\n                if (this.node.pre === this.header) {\n                    throw new RangeError('LinkList iterator access denied!');\n                }\n                this.node = this.node.pre;\n                return this;\n            };\n            this.next = function () {\n                if (this.node === this.header) {\n                    throw new RangeError('LinkList iterator access denied!');\n                }\n                this.node = this.node.next;\n                return this;\n            };\n        }\n        else {\n            this.pre = function () {\n                if (this.node.next === this.header) {\n                    throw new RangeError('LinkList iterator access denied!');\n                }\n                this.node = this.node.next;\n                return this;\n            };\n            this.next = function () {\n                if (this.node === this.header) {\n                    throw new RangeError('LinkList iterator access denied!');\n                }\n                this.node = this.node.pre;\n                return this;\n            };\n        }\n    }\n    get pointer() {\n        if (this.node === this.header) {\n            throw new RangeError('LinkList iterator access denied!');\n        }\n        return this.node.value;\n    }\n    set pointer(newValue) {\n        if (this.node === this.header) {\n            throw new RangeError('LinkList iterator access denied!');\n        }\n        this.node.value = newValue;\n    }\n    equals(obj) {\n        return this.node === obj.node;\n    }\n    copy() {\n        return new LinkListIterator(this.node, this.header, this.iteratorType);\n    }\n}\nexports.LinkListIterator = LinkListIterator;\nclass LinkList extends index_1.default {\n    constructor(container = []) {\n        super();\n        this.header = new LinkNode();\n        this.head = undefined;\n        this.tail = undefined;\n        container.forEach(element => this.pushBack(element));\n    }\n    clear() {\n        this.length = 0;\n        this.head = this.tail = undefined;\n        this.header.pre = this.header.next = undefined;\n    }\n    begin() {\n        return new LinkListIterator(this.head || this.header, this.header);\n    }\n    end() {\n        return new LinkListIterator(this.header, this.header);\n    }\n    rBegin() {\n        return new LinkListIterator(this.tail || this.header, this.header, index_2.ContainerIterator.REVERSE);\n    }\n    rEnd() {\n        return new LinkListIterator(this.header, this.header, index_2.ContainerIterator.REVERSE);\n    }\n    front() {\n        return this.head ? this.head.value : undefined;\n    }\n    back() {\n        return this.tail ? this.tail.value : undefined;\n    }\n    forEach(callback) {\n        if (!this.length)\n            return;\n        let curNode = this.head;\n        let index = 0;\n        while (curNode !== this.header) {\n            callback(curNode.value, index++);\n            curNode = curNode.next;\n        }\n    }\n    getElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        let curNode = this.head;\n        while (pos--) {\n            curNode = curNode.next;\n        }\n        return curNode.value;\n    }\n    eraseElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        if (pos === 0)\n            this.popFront();\n        else if (pos === this.length - 1)\n            this.popBack();\n        else {\n            let curNode = this.head;\n            while (pos--) {\n                curNode = curNode.next;\n            }\n            curNode = curNode;\n            const pre = curNode.pre;\n            const next = curNode.next;\n            next.pre = pre;\n            pre.next = next;\n            this.length -= 1;\n        }\n    }\n    eraseElementByValue(value) {\n        while (this.head && this.head.value === value)\n            this.popFront();\n        while (this.tail && this.tail.value === value)\n            this.popBack();\n        if (!this.head)\n            return;\n        let curNode = this.head;\n        while (curNode !== this.header) {\n            if (curNode.value === value) {\n                const pre = curNode.pre;\n                const next = curNode.next;\n                if (next)\n                    next.pre = pre;\n                if (pre)\n                    pre.next = next;\n                this.length -= 1;\n            }\n            curNode = curNode.next;\n        }\n    }\n    eraseElementByIterator(iter) {\n        // @ts-ignore\n        const node = iter.node;\n        if (node === this.header) {\n            throw new RangeError('Invalid iterator');\n        }\n        iter = iter.next();\n        if (this.head === node)\n            this.popFront();\n        else if (this.tail === node)\n            this.popBack();\n        else {\n            const pre = node.pre;\n            const next = node.next;\n            if (next)\n                next.pre = pre;\n            if (pre)\n                pre.next = next;\n            this.length -= 1;\n        }\n        return iter;\n    }\n    pushBack(element) {\n        this.length += 1;\n        const newTail = new LinkNode(element);\n        if (!this.tail) {\n            this.head = this.tail = newTail;\n            this.header.next = this.head;\n            this.head.pre = this.header;\n        }\n        else {\n            this.tail.next = newTail;\n            newTail.pre = this.tail;\n            this.tail = newTail;\n        }\n        this.tail.next = this.header;\n        this.header.pre = this.tail;\n    }\n    popBack() {\n        if (!this.tail)\n            return;\n        this.length -= 1;\n        if (this.head === this.tail) {\n            this.head = this.tail = undefined;\n            this.header.next = undefined;\n        }\n        else {\n            this.tail = this.tail.pre;\n            if (this.tail)\n                this.tail.next = undefined;\n        }\n        this.header.pre = this.tail;\n        if (this.tail)\n            this.tail.next = this.header;\n    }\n    setElementByPos(pos, element) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        let curNode = this.head;\n        while (pos--) {\n            curNode = curNode.next;\n        }\n        curNode.value = element;\n    }\n    insert(pos, element, num = 1) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length);\n        if (num <= 0)\n            return;\n        if (pos === 0) {\n            while (num--)\n                this.pushFront(element);\n        }\n        else if (pos === this.length) {\n            while (num--)\n                this.pushBack(element);\n        }\n        else {\n            let curNode = this.head;\n            for (let i = 1; i < pos; ++i) {\n                curNode = curNode.next;\n            }\n            const next = curNode.next;\n            this.length += num;\n            while (num--) {\n                curNode.next = new LinkNode(element);\n                curNode.next.pre = curNode;\n                curNode = curNode.next;\n            }\n            curNode.next = next;\n            if (next)\n                next.pre = curNode;\n        }\n    }\n    find(element) {\n        if (!this.head)\n            return this.end();\n        let curNode = this.head;\n        while (curNode !== this.header) {\n            if (curNode.value === element) {\n                return new LinkListIterator(curNode, this.header);\n            }\n            curNode = curNode.next;\n        }\n        return this.end();\n    }\n    reverse() {\n        if (this.length <= 1)\n            return;\n        let pHead = this.head;\n        let pTail = this.tail;\n        let cnt = 0;\n        while ((cnt << 1) < this.length) {\n            const tmp = pHead.value;\n            pHead.value = pTail.value;\n            pTail.value = tmp;\n            pHead = pHead.next;\n            pTail = pTail.pre;\n            cnt += 1;\n        }\n    }\n    unique() {\n        if (this.length <= 1)\n            return;\n        let curNode = this.head;\n        while (curNode !== this.header) {\n            let tmpNode = curNode;\n            while (tmpNode.next && tmpNode.value === tmpNode.next.value) {\n                tmpNode = tmpNode.next;\n                this.length -= 1;\n            }\n            curNode.next = tmpNode.next;\n            if (curNode.next)\n                curNode.next.pre = curNode;\n            curNode = curNode.next;\n        }\n    }\n    sort(cmp) {\n        if (this.length <= 1)\n            return;\n        const arr = [];\n        this.forEach(element => arr.push(element));\n        arr.sort(cmp);\n        let curNode = this.head;\n        arr.forEach((element) => {\n            curNode.value = element;\n            curNode = curNode.next;\n        });\n    }\n    /**\n     * @description Push an element to the front.\n     * @param element The element you want to push.\n     */\n    pushFront(element) {\n        this.length += 1;\n        const newHead = new LinkNode(element);\n        if (!this.head) {\n            this.head = this.tail = newHead;\n            this.tail.next = this.header;\n            this.header.pre = this.tail;\n        }\n        else {\n            newHead.next = this.head;\n            this.head.pre = newHead;\n            this.head = newHead;\n        }\n        this.header.next = this.head;\n        this.head.pre = this.header;\n    }\n    /**\n     * @description Removes the first element.\n     */\n    popFront() {\n        if (!this.head)\n            return;\n        this.length -= 1;\n        if (this.head === this.tail) {\n            this.head = this.tail = undefined;\n            this.header.pre = this.tail;\n        }\n        else {\n            this.head = this.head.next;\n            if (this.head)\n                this.head.pre = this.header;\n        }\n        this.header.next = this.head;\n    }\n    /**\n     * @description Merges two sorted lists.\n     * @param list The other list you want to merge (must be sorted).\n     */\n    merge(list) {\n        if (!this.head) {\n            list.forEach(element => this.pushBack(element));\n            return;\n        }\n        let curNode = this.head;\n        list.forEach(element => {\n            while (curNode &&\n                curNode !== this.header &&\n                curNode.value <= element) {\n                curNode = curNode.next;\n            }\n            if (curNode === this.header) {\n                this.pushBack(element);\n                curNode = this.tail;\n            }\n            else if (curNode === this.head) {\n                this.pushFront(element);\n                curNode = this.head;\n            }\n            else {\n                this.length += 1;\n                const pre = curNode.pre;\n                pre.next = new LinkNode(element);\n                pre.next.pre = pre;\n                pre.next.next = curNode;\n                curNode.pre = pre.next;\n            }\n        });\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            if (!this.head)\n                return;\n            let curNode = this.head;\n            while (curNode !== this.header) {\n                yield curNode.value;\n                curNode = curNode.next;\n            }\n        }.bind(this)();\n    }\n}\nexports.default = LinkList;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OrderedSetIterator = void 0;\nconst index_1 = __importDefault(require(\"./Base/index\"));\nconst index_2 = require(\"../ContainerBase/index\");\nconst checkParams_1 = require(\"../../utils/checkParams\");\nconst TreeIterator_1 = __importDefault(require(\"./Base/TreeIterator\"));\nclass OrderedSetIterator extends TreeIterator_1.default {\n    get pointer() {\n        if (this.node === this.header) {\n            throw new RangeError('OrderedSet iterator access denied!');\n        }\n        return this.node.key;\n    }\n    copy() {\n        return new OrderedSetIterator(this.node, this.header, this.iteratorType);\n    }\n}\nexports.OrderedSetIterator = OrderedSetIterator;\nclass OrderedSet extends index_1.default {\n    constructor(container = [], cmp) {\n        super(cmp);\n        this.iterationFunc = function* (curNode) {\n            if (curNode === undefined)\n                return;\n            yield* this.iterationFunc(curNode.left);\n            yield curNode.key;\n            yield* this.iterationFunc(curNode.right);\n        };\n        container.forEach((element) => this.insert(element));\n        this.iterationFunc = this.iterationFunc.bind(this);\n    }\n    begin() {\n        return new OrderedSetIterator(this.header.left || this.header, this.header);\n    }\n    end() {\n        return new OrderedSetIterator(this.header, this.header);\n    }\n    rBegin() {\n        return new OrderedSetIterator(this.header.right || this.header, this.header, index_2.ContainerIterator.REVERSE);\n    }\n    rEnd() {\n        return new OrderedSetIterator(this.header, this.header, index_2.ContainerIterator.REVERSE);\n    }\n    front() {\n        return this.header.left ? this.header.left.key : undefined;\n    }\n    back() {\n        return this.header.right ? this.header.right.key : undefined;\n    }\n    forEach(callback) {\n        let index = 0;\n        for (const element of this)\n            callback(element, index++);\n    }\n    getElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        let res;\n        let index = 0;\n        for (const element of this) {\n            if (index === pos) {\n                res = element;\n            }\n            index += 1;\n        }\n        return res;\n    }\n    /**\n     * @description Insert element to set.\n     * @param key The key want to insert.\n     * @param hint You can give an iterator hint to improve insertion efficiency.\n     */\n    insert(key, hint) {\n        this.set(key, undefined, hint);\n    }\n    find(element) {\n        const curNode = this.findElementNode(this.root, element);\n        if (curNode !== undefined) {\n            return new OrderedSetIterator(curNode, this.header);\n        }\n        return this.end();\n    }\n    lowerBound(key) {\n        const resNode = this._lowerBound(this.root, key);\n        return new OrderedSetIterator(resNode, this.header);\n    }\n    upperBound(key) {\n        const resNode = this._upperBound(this.root, key);\n        return new OrderedSetIterator(resNode, this.header);\n    }\n    reverseLowerBound(key) {\n        const resNode = this._reverseLowerBound(this.root, key);\n        return new OrderedSetIterator(resNode, this.header);\n    }\n    reverseUpperBound(key) {\n        const resNode = this._reverseUpperBound(this.root, key);\n        return new OrderedSetIterator(resNode, this.header);\n    }\n    union(other) {\n        other.forEach((element) => this.insert(element));\n    }\n    [Symbol.iterator]() {\n        return this.iterationFunc(this.root);\n    }\n}\nexports.default = OrderedSet;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TreeNode_1 = __importDefault(require(\"./TreeNode\"));\nconst index_1 = require(\"../../ContainerBase/index\");\nconst checkParams_1 = require(\"../../../utils/checkParams\");\nclass TreeContainer extends index_1.Container {\n    constructor(cmp = (x, y) => {\n        if (x < y)\n            return -1;\n        if (x > y)\n            return 1;\n        return 0;\n    }) {\n        super();\n        this.root = undefined;\n        this.header = new TreeNode_1.default();\n        /**\n         * @description InOrder traversal the tree.\n         * @protected\n         */\n        this.inOrderTraversal = (curNode, callback) => {\n            if (curNode === undefined)\n                return false;\n            const ifReturn = this.inOrderTraversal(curNode.left, callback);\n            if (ifReturn)\n                return true;\n            if (callback(curNode))\n                return true;\n            return this.inOrderTraversal(curNode.right, callback);\n        };\n        this.cmp = cmp;\n    }\n    /**\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @return TreeNode which key is greater than or equals to the given key.\n     * @protected\n     */\n    _lowerBound(curNode, key) {\n        let resNode;\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult < 0) {\n                curNode = curNode.right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode.left;\n            }\n            else\n                return curNode;\n        }\n        return resNode === undefined ? this.header : resNode;\n    }\n    /**\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @return TreeNode which key is greater than the given key.\n     * @protected\n     */\n    _upperBound(curNode, key) {\n        let resNode;\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult <= 0) {\n                curNode = curNode.right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode.left;\n            }\n        }\n        return resNode === undefined ? this.header : resNode;\n    }\n    /**\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @return TreeNode which key is less than or equals to the given key.\n     * @protected\n     */\n    _reverseLowerBound(curNode, key) {\n        let resNode;\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode.right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode.left;\n            }\n            else\n                return curNode;\n        }\n        return resNode === undefined ? this.header : resNode;\n    }\n    /**\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @return TreeNode which key is less than the given key.\n     * @protected\n     */\n    _reverseUpperBound(curNode, key) {\n        let resNode;\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode.right;\n            }\n            else if (cmpResult >= 0) {\n                curNode = curNode.left;\n            }\n        }\n        return resNode === undefined ? this.header : resNode;\n    }\n    /**\n     * @description Make self balance after erase a node.\n     * @param curNode The node want to remove.\n     * @protected\n     */\n    eraseNodeSelfBalance(curNode) {\n        while (true) {\n            const parentNode = curNode.parent;\n            if (parentNode === this.header)\n                return;\n            if (curNode.color === TreeNode_1.default.RED) {\n                curNode.color = TreeNode_1.default.BLACK;\n                return;\n            }\n            if (curNode === parentNode.left) {\n                const brother = parentNode.right;\n                if (brother.color === TreeNode_1.default.RED) {\n                    brother.color = TreeNode_1.default.BLACK;\n                    parentNode.color = TreeNode_1.default.RED;\n                    if (parentNode === this.root) {\n                        this.root = parentNode.rotateLeft();\n                    }\n                    else\n                        parentNode.rotateLeft();\n                }\n                else if (brother.color === TreeNode_1.default.BLACK) {\n                    if (brother.right && brother.right.color === TreeNode_1.default.RED) {\n                        brother.color = parentNode.color;\n                        parentNode.color = TreeNode_1.default.BLACK;\n                        brother.right.color = TreeNode_1.default.BLACK;\n                        if (parentNode === this.root) {\n                            this.root = parentNode.rotateLeft();\n                        }\n                        else\n                            parentNode.rotateLeft();\n                        return;\n                    }\n                    else if (brother.left && brother.left.color === TreeNode_1.default.RED) {\n                        brother.color = TreeNode_1.default.RED;\n                        brother.left.color = TreeNode_1.default.BLACK;\n                        brother.rotateRight();\n                    }\n                    else {\n                        brother.color = TreeNode_1.default.RED;\n                        curNode = parentNode;\n                    }\n                }\n            }\n            else {\n                const brother = parentNode.left;\n                if (brother.color === TreeNode_1.default.RED) {\n                    brother.color = TreeNode_1.default.BLACK;\n                    parentNode.color = TreeNode_1.default.RED;\n                    if (parentNode === this.root) {\n                        this.root = parentNode.rotateRight();\n                    }\n                    else\n                        parentNode.rotateRight();\n                }\n                else {\n                    if (brother.left && brother.left.color === TreeNode_1.default.RED) {\n                        brother.color = parentNode.color;\n                        parentNode.color = TreeNode_1.default.BLACK;\n                        brother.left.color = TreeNode_1.default.BLACK;\n                        if (parentNode === this.root) {\n                            this.root = parentNode.rotateRight();\n                        }\n                        else\n                            parentNode.rotateRight();\n                        return;\n                    }\n                    else if (brother.right && brother.right.color === TreeNode_1.default.RED) {\n                        brother.color = TreeNode_1.default.RED;\n                        brother.right.color = TreeNode_1.default.BLACK;\n                        brother.rotateLeft();\n                    }\n                    else {\n                        brother.color = TreeNode_1.default.RED;\n                        curNode = parentNode;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @description Remove a node.\n     * @param curNode The node you want to remove.\n     * @protected\n     */\n    eraseNode(curNode) {\n        if (this.length === 1) {\n            this.clear();\n            return;\n        }\n        let swapNode = curNode;\n        while (swapNode.left || swapNode.right) {\n            if (swapNode.right) {\n                swapNode = swapNode.right;\n                while (swapNode.left)\n                    swapNode = swapNode.left;\n            }\n            else if (swapNode.left) {\n                swapNode = swapNode.left;\n            }\n            [curNode.key, swapNode.key] = [swapNode.key, curNode.key];\n            [curNode.value, swapNode.value] = [swapNode.value, curNode.value];\n            curNode = swapNode;\n        }\n        if (this.header.left === swapNode) {\n            this.header.left = swapNode.parent;\n        }\n        else if (this.header.right === swapNode) {\n            this.header.right = swapNode.parent;\n        }\n        this.eraseNodeSelfBalance(swapNode);\n        swapNode.remove();\n        this.length -= 1;\n        this.root.color = TreeNode_1.default.BLACK;\n    }\n    /**\n     * @description Make self balance after insert a node.\n     * @param curNode The node want to insert.\n     * @protected\n     */\n    insertNodeSelfBalance(curNode) {\n        while (true) {\n            const parentNode = curNode.parent;\n            if (parentNode.color === TreeNode_1.default.BLACK)\n                return;\n            const grandParent = parentNode.parent;\n            if (parentNode === grandParent.left) {\n                const uncle = grandParent.right;\n                if (uncle && uncle.color === TreeNode_1.default.RED) {\n                    uncle.color = parentNode.color = TreeNode_1.default.BLACK;\n                    if (grandParent === this.root)\n                        return;\n                    grandParent.color = TreeNode_1.default.RED;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode.right) {\n                    curNode.color = TreeNode_1.default.BLACK;\n                    if (curNode.left)\n                        curNode.left.parent = parentNode;\n                    if (curNode.right)\n                        curNode.right.parent = grandParent;\n                    parentNode.right = curNode.left;\n                    grandParent.left = curNode.right;\n                    curNode.left = parentNode;\n                    curNode.right = grandParent;\n                    if (grandParent === this.root) {\n                        this.root = curNode;\n                        this.header.parent = curNode;\n                    }\n                    else {\n                        const GP = grandParent.parent;\n                        if (GP.left === grandParent) {\n                            GP.left = curNode;\n                        }\n                        else\n                            GP.right = curNode;\n                    }\n                    curNode.parent = grandParent.parent;\n                    parentNode.parent = curNode;\n                    grandParent.parent = curNode;\n                }\n                else {\n                    parentNode.color = TreeNode_1.default.BLACK;\n                    if (grandParent === this.root) {\n                        this.root = grandParent.rotateRight();\n                    }\n                    else\n                        grandParent.rotateRight();\n                }\n                grandParent.color = TreeNode_1.default.RED;\n            }\n            else {\n                const uncle = grandParent.left;\n                if (uncle && uncle.color === TreeNode_1.default.RED) {\n                    uncle.color = parentNode.color = TreeNode_1.default.BLACK;\n                    if (grandParent === this.root)\n                        return;\n                    grandParent.color = TreeNode_1.default.RED;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode.left) {\n                    curNode.color = TreeNode_1.default.BLACK;\n                    if (curNode.left)\n                        curNode.left.parent = grandParent;\n                    if (curNode.right)\n                        curNode.right.parent = parentNode;\n                    grandParent.right = curNode.left;\n                    parentNode.left = curNode.right;\n                    curNode.left = grandParent;\n                    curNode.right = parentNode;\n                    if (grandParent === this.root) {\n                        this.root = curNode;\n                        this.header.parent = curNode;\n                    }\n                    else {\n                        const GP = grandParent.parent;\n                        if (GP.left === grandParent) {\n                            GP.left = curNode;\n                        }\n                        else\n                            GP.right = curNode;\n                    }\n                    curNode.parent = grandParent.parent;\n                    parentNode.parent = curNode;\n                    grandParent.parent = curNode;\n                }\n                else {\n                    parentNode.color = TreeNode_1.default.BLACK;\n                    if (grandParent === this.root) {\n                        this.root = grandParent.rotateLeft();\n                    }\n                    else\n                        grandParent.rotateLeft();\n                }\n                grandParent.color = TreeNode_1.default.RED;\n            }\n            return;\n        }\n    }\n    /**\n     * @description Find node which key is equals to the given key.\n     * @param curNode The starting node of the search.\n     * @param key The key you want to search.\n     * @protected\n     */\n    findElementNode(curNode, key) {\n        while (curNode) {\n            const cmpResult = this.cmp(curNode.key, key);\n            if (cmpResult < 0) {\n                curNode = curNode.right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode.left;\n            }\n            else\n                return curNode;\n        }\n        return curNode;\n    }\n    /**\n     * @description Insert a key-value pair or set value by the given key.\n     * @param key The key want to insert.\n     * @param value The value want to set.\n     * @param hint You can give an iterator hint to improve insertion efficiency.\n     * @protected\n     */\n    set(key, value, hint) {\n        if (this.root === undefined) {\n            this.length += 1;\n            this.root = new TreeNode_1.default(key, value);\n            this.root.color = TreeNode_1.default.BLACK;\n            this.root.parent = this.header;\n            this.header.parent = this.root;\n            this.header.left = this.root;\n            this.header.right = this.root;\n            return;\n        }\n        let curNode;\n        const minNode = this.header.left;\n        const compareToMin = this.cmp(minNode.key, key);\n        if (compareToMin === 0) {\n            minNode.value = value;\n            return;\n        }\n        else if (compareToMin > 0) {\n            minNode.left = new TreeNode_1.default(key, value);\n            minNode.left.parent = minNode;\n            curNode = minNode.left;\n            this.header.left = curNode;\n        }\n        else {\n            const maxNode = this.header.right;\n            const compareToMax = this.cmp(maxNode.key, key);\n            if (compareToMax === 0) {\n                maxNode.value = value;\n                return;\n            }\n            else if (compareToMax < 0) {\n                maxNode.right = new TreeNode_1.default(key, value);\n                maxNode.right.parent = maxNode;\n                curNode = maxNode.right;\n                this.header.right = curNode;\n            }\n            else {\n                if (hint !== undefined) {\n                    // @ts-ignore\n                    const iterNode = hint.node;\n                    if (iterNode !== this.header) {\n                        const iterCmpRes = this.cmp(iterNode.key, key);\n                        if (iterCmpRes === 0) {\n                            iterNode.value = value;\n                            return;\n                        }\n                        else if (iterCmpRes > 0) {\n                            const preNode = iterNode.pre();\n                            const preCmpRes = this.cmp(preNode.key, key);\n                            if (preCmpRes === 0) {\n                                preNode.value = value;\n                                return;\n                            }\n                            else if (preCmpRes < 0) {\n                                curNode = new TreeNode_1.default(key, value);\n                                if (preNode.right === undefined) {\n                                    preNode.right = curNode;\n                                    curNode.parent = preNode;\n                                }\n                                else {\n                                    iterNode.left = curNode;\n                                    curNode.parent = iterNode;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (curNode === undefined) {\n                    curNode = this.root;\n                    while (true) {\n                        const cmpResult = this.cmp(curNode.key, key);\n                        if (cmpResult > 0) {\n                            if (curNode.left === undefined) {\n                                curNode.left = new TreeNode_1.default(key, value);\n                                curNode.left.parent = curNode;\n                                curNode = curNode.left;\n                                break;\n                            }\n                            curNode = curNode.left;\n                        }\n                        else if (cmpResult < 0) {\n                            if (curNode.right === undefined) {\n                                curNode.right = new TreeNode_1.default(key, value);\n                                curNode.right.parent = curNode;\n                                curNode = curNode.right;\n                                break;\n                            }\n                            curNode = curNode.right;\n                        }\n                        else {\n                            curNode.value = value;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        this.length += 1;\n        this.insertNodeSelfBalance(curNode);\n    }\n    clear() {\n        this.length = 0;\n        this.root = undefined;\n        this.header.parent = undefined;\n        this.header.left = this.header.right = undefined;\n    }\n    /**\n     * @description Update node's key by iterator.\n     * @param iter The iterator you want to change.\n     * @param key The key you want to update.\n     * @return Boolean about if the modification is successful.\n     */\n    updateKeyByIterator(iter, key) {\n        // @ts-ignore\n        const node = iter.node;\n        if (node === this.header) {\n            throw new TypeError('Invalid iterator!');\n        }\n        if (this.length === 1) {\n            node.key = key;\n            return true;\n        }\n        if (node === this.header.left) {\n            if (this.cmp(node.next().key, key) > 0) {\n                node.key = key;\n                return true;\n            }\n            return false;\n        }\n        if (node === this.header.right) {\n            if (this.cmp(node.pre().key, key) < 0) {\n                node.key = key;\n                return true;\n            }\n            return false;\n        }\n        const preKey = node.pre().key;\n        if (this.cmp(preKey, key) >= 0)\n            return false;\n        const nextKey = node.next().key;\n        if (this.cmp(nextKey, key) <= 0)\n            return false;\n        node.key = key;\n        return true;\n    }\n    eraseElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        let index = 0;\n        this.inOrderTraversal(this.root, curNode => {\n            if (pos === index) {\n                this.eraseNode(curNode);\n                return true;\n            }\n            index += 1;\n            return false;\n        });\n    }\n    /**\n     * @description Remove the element of the specified key.\n     * @param key The key you want to remove.\n     */\n    eraseElementByKey(key) {\n        if (!this.length)\n            return;\n        const curNode = this.findElementNode(this.root, key);\n        if (curNode === undefined)\n            return;\n        this.eraseNode(curNode);\n    }\n    eraseElementByIterator(iter) {\n        // @ts-ignore\n        const node = iter.node;\n        if (node === this.header) {\n            throw new RangeError('Invalid iterator');\n        }\n        if (node.right === undefined) {\n            iter = iter.next();\n        }\n        this.eraseNode(node);\n        return iter;\n    }\n    /**\n     * @description Get the height of the tree.\n     * @return Number about the height of the RB-tree.\n     */\n    getHeight() {\n        if (!this.length)\n            return 0;\n        const traversal = (curNode) => {\n            if (!curNode)\n                return 0;\n            return Math.max(traversal(curNode.left), traversal(curNode.right)) + 1;\n        };\n        return traversal(this.root);\n    }\n}\nexports.default = TreeContainer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass TreeNode {\n    constructor(key, value) {\n        this.color = true;\n        this.key = undefined;\n        this.value = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.parent = undefined;\n        this.key = key;\n        this.value = value;\n    }\n    /**\n     * @description Get the pre node.\n     * @return TreeNode about the pre node.\n     */\n    pre() {\n        let preNode = this;\n        if (preNode.color === TreeNode.RED &&\n            preNode.parent.parent === preNode) {\n            preNode = preNode.right;\n        }\n        else if (preNode.left) {\n            preNode = preNode.left;\n            while (preNode.right) {\n                preNode = preNode.right;\n            }\n        }\n        else {\n            let pre = preNode.parent;\n            while (pre.left === preNode) {\n                preNode = pre;\n                pre = preNode.parent;\n            }\n            preNode = pre;\n        }\n        return preNode;\n    }\n    /**\n     * @description Get the next node.\n     * @return TreeNode about the next node.\n     */\n    next() {\n        let nextNode = this;\n        if (nextNode.right) {\n            nextNode = nextNode.right;\n            while (nextNode.left) {\n                nextNode = nextNode.left;\n            }\n        }\n        else {\n            let pre = nextNode.parent;\n            while (pre.right === nextNode) {\n                nextNode = pre;\n                pre = nextNode.parent;\n            }\n            if (nextNode.right !== pre) {\n                nextNode = pre;\n            }\n        }\n        return nextNode;\n    }\n    /**\n     * @description Rotate left.\n     * @return TreeNode about moved to original position after rotation.\n     */\n    rotateLeft() {\n        const PP = this.parent;\n        const V = this.right;\n        const R = V.left;\n        if (PP.parent === this)\n            PP.parent = V;\n        else if (PP.left === this)\n            PP.left = V;\n        else\n            PP.right = V;\n        V.parent = PP;\n        V.left = this;\n        this.parent = V;\n        this.right = R;\n        if (R)\n            R.parent = this;\n        return V;\n    }\n    /**\n     * @description Rotate left.\n     * @return TreeNode about moved to original position after rotation.\n     */\n    rotateRight() {\n        const PP = this.parent;\n        const F = this.left;\n        const K = F.right;\n        if (PP.parent === this)\n            PP.parent = F;\n        else if (PP.left === this)\n            PP.left = F;\n        else\n            PP.right = F;\n        F.parent = PP;\n        F.right = this;\n        this.parent = F;\n        this.left = K;\n        if (K)\n            K.parent = this;\n        return F;\n    }\n    /**\n     * @description Remove this.\n     */\n    remove() {\n        const parent = this.parent;\n        if (this === parent.left) {\n            parent.left = undefined;\n        }\n        else\n            parent.right = undefined;\n    }\n}\nTreeNode.RED = true;\nTreeNode.BLACK = false;\nexports.default = TreeNode;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = require(\"../../ContainerBase/index\");\nclass TreeIterator extends index_1.ContainerIterator {\n    constructor(node, header, iteratorType) {\n        super(iteratorType);\n        this.node = node;\n        this.header = header;\n        if (this.iteratorType === index_1.ContainerIterator.NORMAL) {\n            this.pre = function () {\n                if (this.node === this.header.left) {\n                    throw new RangeError('LinkList iterator access denied!');\n                }\n                this.node = this.node.pre();\n                return this;\n            };\n            this.next = function () {\n                if (this.node === this.header) {\n                    throw new RangeError('LinkList iterator access denied!');\n                }\n                this.node = this.node.next();\n                return this;\n            };\n        }\n        else {\n            this.pre = function () {\n                if (this.node === this.header.right) {\n                    throw new RangeError('LinkList iterator access denied!');\n                }\n                this.node = this.node.next();\n                return this;\n            };\n            this.next = function () {\n                if (this.node === this.header) {\n                    throw new RangeError('LinkList iterator access denied!');\n                }\n                this.node = this.node.pre();\n                return this;\n            };\n        }\n    }\n    equals(obj) {\n        return this.node === obj.node;\n    }\n}\nexports.default = TreeIterator;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OrderedMapIterator = void 0;\nconst index_1 = require(\"../ContainerBase/index\");\nconst checkParams_1 = require(\"../../utils/checkParams\");\nconst index_2 = __importDefault(require(\"./Base/index\"));\nconst TreeIterator_1 = __importDefault(require(\"./Base/TreeIterator\"));\nclass OrderedMapIterator extends TreeIterator_1.default {\n    get pointer() {\n        if (this.node === this.header) {\n            throw new RangeError('OrderedMap iterator access denied');\n        }\n        return new Proxy([], {\n            get: (_, props) => {\n                if (props === '0')\n                    return this.node.key;\n                else if (props === '1')\n                    return this.node.value;\n            },\n            set: (_, props, newValue) => {\n                if (props !== '1') {\n                    throw new TypeError('props must be 1');\n                }\n                this.node.value = newValue;\n                return true;\n            }\n        });\n    }\n    copy() {\n        return new OrderedMapIterator(this.node, this.header, this.iteratorType);\n    }\n}\nexports.OrderedMapIterator = OrderedMapIterator;\nclass OrderedMap extends index_2.default {\n    constructor(container = [], cmp) {\n        super(cmp);\n        this.iterationFunc = function* (curNode) {\n            if (curNode === undefined)\n                return;\n            yield* this.iterationFunc(curNode.left);\n            yield [curNode.key, curNode.value];\n            yield* this.iterationFunc(curNode.right);\n        };\n        this.iterationFunc = this.iterationFunc.bind(this);\n        container.forEach(([key, value]) => this.setElement(key, value));\n    }\n    begin() {\n        return new OrderedMapIterator(this.header.left || this.header, this.header);\n    }\n    end() {\n        return new OrderedMapIterator(this.header, this.header);\n    }\n    rBegin() {\n        return new OrderedMapIterator(this.header.right || this.header, this.header, index_1.ContainerIterator.REVERSE);\n    }\n    rEnd() {\n        return new OrderedMapIterator(this.header, this.header, index_1.ContainerIterator.REVERSE);\n    }\n    front() {\n        if (!this.length)\n            return undefined;\n        const minNode = this.header.left;\n        return [minNode.key, minNode.value];\n    }\n    back() {\n        if (!this.length)\n            return undefined;\n        const maxNode = this.header.right;\n        return [maxNode.key, maxNode.value];\n    }\n    forEach(callback) {\n        let index = 0;\n        for (const pair of this)\n            callback(pair, index++);\n    }\n    lowerBound(key) {\n        const resNode = this._lowerBound(this.root, key);\n        return new OrderedMapIterator(resNode, this.header);\n    }\n    upperBound(key) {\n        const resNode = this._upperBound(this.root, key);\n        return new OrderedMapIterator(resNode, this.header);\n    }\n    reverseLowerBound(key) {\n        const resNode = this._reverseLowerBound(this.root, key);\n        return new OrderedMapIterator(resNode, this.header);\n    }\n    reverseUpperBound(key) {\n        const resNode = this._reverseUpperBound(this.root, key);\n        return new OrderedMapIterator(resNode, this.header);\n    }\n    /**\n     * @description Insert a key-value pair or set value by the given key.\n     * @param key The key want to insert.\n     * @param value The value want to set.\n     * @param hint You can give an iterator hint to improve insertion efficiency.\n     */\n    setElement(key, value, hint) {\n        this.set(key, value, hint);\n    }\n    find(key) {\n        const curNode = this.findElementNode(this.root, key);\n        if (curNode !== undefined) {\n            return new OrderedMapIterator(curNode, this.header);\n        }\n        return this.end();\n    }\n    /**\n     * @description Get the value of the element of the specified key.\n     */\n    getElementByKey(key) {\n        const curNode = this.findElementNode(this.root, key);\n        return curNode ? curNode.value : undefined;\n    }\n    getElementByPos(pos) {\n        (0, checkParams_1.checkWithinAccessParams)(pos, 0, this.length - 1);\n        let res;\n        let index = 0;\n        for (const pair of this) {\n            if (index === pos) {\n                res = pair;\n                break;\n            }\n            index += 1;\n        }\n        return res;\n    }\n    union(other) {\n        other.forEach(([key, value]) => this.setElement(key, value));\n    }\n    [Symbol.iterator]() {\n        return this.iterationFunc(this.root);\n    }\n}\nexports.default = OrderedMap;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = __importDefault(require(\"./Base/index\"));\nconst Vector_1 = __importDefault(require(\"../SequentialContainer/Vector\"));\nconst OrderedSet_1 = __importDefault(require(\"../TreeContainer/OrderedSet\"));\nclass HashSet extends index_1.default {\n    constructor(container = [], initBucketNum, hashFunc) {\n        super(initBucketNum, hashFunc);\n        this.hashTable = [];\n        container.forEach(element => this.insert(element));\n    }\n    reAllocate() {\n        if (this.bucketNum >= index_1.default.maxBucketNum)\n            return;\n        const newHashTable = [];\n        const originalBucketNum = this.bucketNum;\n        this.bucketNum <<= 1;\n        const keys = Object.keys(this.hashTable);\n        const keyNums = keys.length;\n        for (let i = 0; i < keyNums; ++i) {\n            const index = parseInt(keys[i]);\n            const container = this.hashTable[index];\n            const size = container.size();\n            if (size === 0)\n                continue;\n            if (size === 1) {\n                const element = container.front();\n                newHashTable[this.hashFunc(element) & (this.bucketNum - 1)] = new Vector_1.default([element], false);\n                continue;\n            }\n            const lowList = [];\n            const highList = [];\n            container.forEach(element => {\n                const hashCode = this.hashFunc(element);\n                if ((hashCode & originalBucketNum) === 0) {\n                    lowList.push(element);\n                }\n                else\n                    highList.push(element);\n            });\n            if (container instanceof OrderedSet_1.default) {\n                if (lowList.length > index_1.default.untreeifyThreshold) {\n                    newHashTable[index] = new OrderedSet_1.default(lowList);\n                }\n                else if (lowList.length) {\n                    newHashTable[index] = new Vector_1.default(lowList, false);\n                }\n                if (highList.length > index_1.default.untreeifyThreshold) {\n                    newHashTable[index + originalBucketNum] = new OrderedSet_1.default(highList);\n                }\n                else if (highList.length) {\n                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);\n                }\n            }\n            else {\n                if (lowList.length >= index_1.default.treeifyThreshold) {\n                    newHashTable[index] = new OrderedSet_1.default(lowList);\n                }\n                else if (lowList.length) {\n                    newHashTable[index] = new Vector_1.default(lowList, false);\n                }\n                if (highList.length >= index_1.default.treeifyThreshold) {\n                    newHashTable[index + originalBucketNum] = new OrderedSet_1.default(highList);\n                }\n                else if (highList.length) {\n                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);\n                }\n            }\n        }\n        this.hashTable = newHashTable;\n    }\n    forEach(callback) {\n        const containers = Object.values(this.hashTable);\n        const containersNum = containers.length;\n        let index = 0;\n        for (let i = 0; i < containersNum; ++i) {\n            containers[i].forEach(element => callback(element, index++));\n        }\n    }\n    /**\n     * @description Insert element to hash set.\n     * @param element The element you want to insert.\n     */\n    insert(element) {\n        const index = this.hashFunc(element) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container) {\n            this.hashTable[index] = new Vector_1.default([element], false);\n            this.length += 1;\n        }\n        else {\n            const preSize = container.size();\n            if (container instanceof Vector_1.default) {\n                if (!container.find(element)\n                    .equals(container.end()))\n                    return;\n                container.pushBack(element);\n                if (preSize + 1 >= index_1.default.treeifyThreshold) {\n                    if (this.bucketNum <= index_1.default.minTreeifySize) {\n                        this.length += 1;\n                        this.reAllocate();\n                        return;\n                    }\n                    this.hashTable[index] = new OrderedSet_1.default(container);\n                }\n                this.length += 1;\n            }\n            else {\n                container.insert(element);\n                const curSize = container.size();\n                this.length += curSize - preSize;\n            }\n        }\n        if (this.length > this.bucketNum * index_1.default.sigma) {\n            this.reAllocate();\n        }\n    }\n    eraseElementByKey(key) {\n        const index = this.hashFunc(key) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container)\n            return;\n        const preSize = container.size();\n        if (preSize === 0)\n            return;\n        if (container instanceof Vector_1.default) {\n            container.eraseElementByValue(key);\n            const curSize = container.size();\n            this.length += curSize - preSize;\n        }\n        else {\n            container.eraseElementByKey(key);\n            const curSize = container.size();\n            this.length += curSize - preSize;\n            if (curSize <= index_1.default.untreeifyThreshold) {\n                this.hashTable[index] = new Vector_1.default(container);\n            }\n        }\n    }\n    find(element) {\n        const index = this.hashFunc(element) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container)\n            return false;\n        return !container.find(element)\n            .equals(container.end());\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            const containers = Object.values(this.hashTable);\n            const containersNum = containers.length;\n            for (let i = 0; i < containersNum; ++i) {\n                const container = containers[i];\n                for (const element of container) {\n                    yield element;\n                }\n            }\n        }.bind(this)();\n    }\n}\nexports.default = HashSet;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = require(\"../../ContainerBase/index\");\nclass HashContainer extends index_1.Base {\n    constructor(initBucketNum = 16, hashFunc = (x) => {\n        let str;\n        if (typeof x !== 'string') {\n            str = JSON.stringify(x);\n        }\n        else\n            str = x;\n        let hashCode = 0;\n        const strLength = str.length;\n        for (let i = 0; i < strLength; i++) {\n            const ch = str.charCodeAt(i);\n            hashCode = ((hashCode << 5) - hashCode) + ch;\n            hashCode |= 0;\n        }\n        return hashCode >>> 0;\n    }) {\n        super();\n        if (initBucketNum < 16 || (initBucketNum & (initBucketNum - 1)) !== 0) {\n            throw new RangeError('InitBucketNum range error');\n        }\n        this.bucketNum = this.initBucketNum = initBucketNum;\n        this.hashFunc = hashFunc;\n    }\n    clear() {\n        this.length = 0;\n        this.bucketNum = this.initBucketNum;\n        this.hashTable = [];\n    }\n}\nHashContainer.sigma = 0.75;\nHashContainer.treeifyThreshold = 8;\nHashContainer.untreeifyThreshold = 6;\nHashContainer.minTreeifySize = 64;\nHashContainer.maxBucketNum = (1 << 30);\nexports.default = HashContainer;\n","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = __importDefault(require(\"./Base/index\"));\nconst Vector_1 = __importDefault(require(\"../SequentialContainer/Vector\"));\nconst OrderedMap_1 = __importDefault(require(\"../TreeContainer/OrderedMap\"));\nclass HashMap extends index_1.default {\n    constructor(container = [], initBucketNum, hashFunc) {\n        super(initBucketNum, hashFunc);\n        this.hashTable = [];\n        container.forEach(element => this.setElement(element[0], element[1]));\n    }\n    reAllocate() {\n        if (this.bucketNum >= index_1.default.maxBucketNum)\n            return;\n        const newHashTable = [];\n        const originalBucketNum = this.bucketNum;\n        this.bucketNum <<= 1;\n        const keys = Object.keys(this.hashTable);\n        const keyNums = keys.length;\n        for (let i = 0; i < keyNums; ++i) {\n            const index = parseInt(keys[i]);\n            const container = this.hashTable[index];\n            const size = container.size();\n            if (size === 0)\n                continue;\n            if (size === 1) {\n                const element = container.front();\n                newHashTable[this.hashFunc(element[0]) & (this.bucketNum - 1)] = new Vector_1.default([element], false);\n                continue;\n            }\n            const lowList = [];\n            const highList = [];\n            container.forEach(element => {\n                const hashCode = this.hashFunc(element[0]);\n                if ((hashCode & originalBucketNum) === 0) {\n                    lowList.push(element);\n                }\n                else\n                    highList.push(element);\n            });\n            if (container instanceof OrderedMap_1.default) {\n                if (lowList.length > index_1.default.untreeifyThreshold) {\n                    newHashTable[index] = new OrderedMap_1.default(lowList);\n                }\n                else if (lowList.length) {\n                    newHashTable[index] = new Vector_1.default(lowList, false);\n                }\n                if (highList.length > index_1.default.untreeifyThreshold) {\n                    newHashTable[index + originalBucketNum] = new OrderedMap_1.default(highList);\n                }\n                else if (highList.length) {\n                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);\n                }\n            }\n            else {\n                if (lowList.length >= index_1.default.treeifyThreshold) {\n                    newHashTable[index] = new OrderedMap_1.default(lowList);\n                }\n                else if (lowList.length) {\n                    newHashTable[index] = new Vector_1.default(lowList, false);\n                }\n                if (highList.length >= index_1.default.treeifyThreshold) {\n                    newHashTable[index + originalBucketNum] = new OrderedMap_1.default(highList);\n                }\n                else if (highList.length) {\n                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);\n                }\n            }\n        }\n        this.hashTable = newHashTable;\n    }\n    forEach(callback) {\n        const containers = Object.values(this.hashTable);\n        const containersNum = containers.length;\n        let index = 0;\n        for (let i = 0; i < containersNum; ++i) {\n            containers[i].forEach(element => callback(element, index++));\n        }\n    }\n    /**\n     * @description Insert a new key-value pair to hash map or set value by key.\n     * @param key The key you want to insert.\n     * @param value The value you want to insert.\n     * @example HashMap.setElement(1, 2); // insert a key-value pair [1, 2]\n     */\n    setElement(key, value) {\n        const index = this.hashFunc(key) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container) {\n            this.length += 1;\n            this.hashTable[index] = new Vector_1.default([[key, value]], false);\n        }\n        else {\n            const preSize = container.size();\n            if (container instanceof Vector_1.default) {\n                for (const pair of container) {\n                    if (pair[0] === key) {\n                        pair[1] = value;\n                        return;\n                    }\n                }\n                container.pushBack([key, value]);\n                if (preSize + 1 >= HashMap.treeifyThreshold) {\n                    if (this.bucketNum <= HashMap.minTreeifySize) {\n                        this.length += 1;\n                        this.reAllocate();\n                        return;\n                    }\n                    this.hashTable[index] = new OrderedMap_1.default(this.hashTable[index]);\n                }\n                this.length += 1;\n            }\n            else {\n                container.setElement(key, value);\n                const curSize = container.size();\n                this.length += curSize - preSize;\n            }\n        }\n        if (this.length > this.bucketNum * HashMap.sigma) {\n            this.reAllocate();\n        }\n    }\n    /**\n     * @description Get the value of the element which has the specified key.\n     * @param key The key you want to get.\n     */\n    getElementByKey(key) {\n        const index = this.hashFunc(key) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container)\n            return undefined;\n        if (container instanceof OrderedMap_1.default) {\n            return container.getElementByKey(key);\n        }\n        else {\n            for (const pair of container) {\n                if (pair[0] === key)\n                    return pair[1];\n            }\n            return undefined;\n        }\n    }\n    eraseElementByKey(key) {\n        const index = this.hashFunc(key) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container)\n            return;\n        if (container instanceof Vector_1.default) {\n            let pos = 0;\n            for (const pair of container) {\n                if (pair[0] === key) {\n                    container.eraseElementByPos(pos);\n                    this.length -= 1;\n                    return;\n                }\n                pos += 1;\n            }\n        }\n        else {\n            const preSize = container.size();\n            container.eraseElementByKey(key);\n            const curSize = container.size();\n            this.length += curSize - preSize;\n            if (curSize <= index_1.default.untreeifyThreshold) {\n                this.hashTable[index] = new Vector_1.default(container);\n            }\n        }\n    }\n    find(key) {\n        const index = this.hashFunc(key) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container)\n            return false;\n        if (container instanceof OrderedMap_1.default) {\n            return !container.find(key)\n                .equals(container.end());\n        }\n        for (const pair of container) {\n            if (pair[0] === key)\n                return true;\n        }\n        return false;\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            const containers = Object.values(this.hashTable);\n            const containersNum = containers.length;\n            for (let i = 0; i < containersNum; ++i) {\n                const container = containers[i];\n                for (const element of container) {\n                    yield element;\n                }\n            }\n        }.bind(this)();\n    }\n}\nexports.default = HashMap;\n"]}